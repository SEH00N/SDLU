# <center>**멀티스레딩 기초**</center>

## 목차
1. 스레드 사용 방법
2. 환경 설정
3. Thread
4. ThreadPool
5. Task
6. Async
7. 문제 발생시키기
8. Lock


<br/>

## 1. 스레드 사용 방법
우리가 사용하는 C#에선 총 네가지 방법으로 스레딩을 할 수 있다.

1. Thread
   - 이름 그대로 하나의 스레드를 생성하는 방식
2. ThreadPool
   - 사전에 스레드를 생성해두어 풀링하는 형식
3. Task
   - ThreadPool의 업그레이드 버전
4. Async/Awate
   - 내부적으로는 Task로 작동하는 비동기 프로그래밍 방식
   - 유니티의 코루틴과 비슷함

<br/>

## 2. 환경 설정
C# 콘솔 앱 선택<br/>
프로젝트 이름과 솔루션 이름을 Threading으로 설정<br/>
.NET 6.0 버전, 최상위 문 사용 안 함으로 프로젝트 생성

<br/>

## 3. Thread

### ThreadTest1
스레드를 두개 생성한 후 각각 생성자 매개변수로 Thread1, Thread2 메소드를 넘겨준다.<br/>
이름을 바꾼 후 각각 실행시켜준다.

```
Thread1, 1번 스레드
Thread2, 2번 스레드
```

또는

```
Thread2, 2번 스레드
Thread1, 1번 스레드
```

와 같이 출력되는 것을 볼 수 있다.<br/>
이로써 CPU가 스케줄링할 때 무엇을 먼저 하는 실행하는지에 따라 스레드의 실행 순서가 바뀐다는 것을 알 수 있다.

### ThreadTest2
아까와 같은 코드지만 이번엔 "This is main"이라는 출력을 하나 더 추가했다.

```
This is main
Hello, Thread1!
Hello, Thread2!
```

또는

```
This is main
Hello, Thread2!
Hello, Thread1!
```

와 같이 출력되는 것을 볼 수 있을 것이다.

<br/>

이번엔 thread1과 thread2의 Join() 함수를 호출한 후 실행해보자.

```
Hello, Thread1!
Hello, Thread2!
This is main
```

또는

```
Hello, Thread2!
Hello, Thread1!
This is main
```

와 같이 출력된다.

Join함수는 해당 스레드의 작업이 끝날 때까지 해당 스레드를 호출한 스레드를 멈추게 한다.<br/>
따라서 Join을 걸면 "This is main" 메세지가 항상 모든 스레드가 끝난 시점인 마지막에 뜨지만<br/>
Join을 하지 않으면 처음에 뜰지 중간에 뜰지 마지막에 뜰지 모른다.<br/>
하지만 대부분은 스레드 실행 순서 탓에 This is main이 처음에 뜰 것이다.

### ThreadTest3
첫 코드와 같은 코드지만 이번엔 "This is main"이라는 출력과 Thread1, Thread2의 작업을 for문으로 100번씩 실행하게 하였다.

```
This is main
Hello, Thread1! : 0
Hello, Thread1! : 1
Hello, Thread1! : 2
Hello, Thread1! : 3
...
Hello, Thread2! : 99
```

또는

```
This is main
Hello, Thread2! : 0
Hello, Thread2! : 1
Hello, Thread2! : 2
Hello, Thread2! : 3
...
Hello, Thread1! : 99
```

와 같이 출력된다.

이번엔 스레드들을 시작시키기 전에 각각 스레드의 IsBackground 속성을 true로 만들고 실행해보자.

```
This is main
Hello, Thread1! : 0
Hello, Thread1! : 1
Hello, Thread1! : 2
Hello, Thread1! : 3
...
Hello, Thread1! : 12
```

이런 식으로 예상했던 결과와 달리 애매하게 중간에서 종료되는 경우가 발생한다.

스레드는 BackgroundThread과 Foreground 스레드로 나뉜다.<br/>
BackgroundThread는 모든 Foreground 스레드가 종료되었을 때 같이 종료되는 스레드<br/>
메인스레드같은 하나의 Foreground 스레드라도 존재한다면 프로세스는 종료되지 않음

즉 생성자를 통해 생성한 스레드는 기본적으로 ForegroundThread로 분류되기 때문에 1번 테스트와 같은 결과가 나올 수 있었던 것이다.

<br/>

## 4. ThreadPool
스레드풀은 ThreadPool.QueueUserWorkItem() 함수를 통해 작업을 실행시킬 수 있다.

첫번째 매개변수로는 Action<object?> 형태의 콜백을 받고 두번째 매개변수로는 콜백의 매개변수로 넘길 object? 타입을 받는다.

실행 결과
```
This is main
Work1 : 10
Work2 : This is String
```

또는

```
This is main
Work2 : This is String
Work1 : 10
```

<br/>

## 5. Task
스태틱 함수 Task.Run() 또는 Task 객체를 생성해서 작업을 실행시킬 수 있다.<br/>
또한 Task.WaitAll()을 통해 Thread.Join() 함수를 대체 할 수 있다.

<br/>

## 6. Async
함수에 async 키워드를 붙여 비동기 함수를 생성할 수 있다.<br/>
비동기 함수는 내부적으로 Task를 활용해 작동된다.

### AsyncTest1
async 함수 내에서는 await이라는 키워드를 쓸 수 있다.<br/>
await은 작업을 기다리는 키워드로 await 오른쪽에 오는 Task 객체의 작업을 실행시킨 후 작업이 모두 끝날 때까지 기다린다.<br/>
이 때 함수를 호출했던 기존의 스레드를 벗어나 새로운 스레드 즉 Task에서 작업이 실행되기에 비동기 함수라 불리는 것이다.

즉 await을 사용하지 않는 async 함수는 동기 함수와 다를 바 없다.

Task.Delay(int millisecondsDelay) 함수는 매개변수로 들어온 밀리초 만큼의 딜레이를 가지는 작업을 반환한다.<br/>
즉 해당 작업을 await시킬 시에 매개변수로 넘긴 밀리초 만큼 기다리게 된다.

딜레이는 HelloAsync 함수가 실행중인 스레드에 적용되게에 "Hello, Async! : 0" 이 출력된 후 바로 "Hello, Main!" 메세지가 바로 출력되는 것을 볼 수 있다.<br/>
그 후로는 0.5초의 딜레이를 가지며 "Hello, Async! : n" 메세지가 출력된다.

실행 결과

```
Hello, Async! : 0 (0.5초 딜레이)
Hello, Main!
Hello, Async! : 1 (0.5초 딜레이)
Hello, Async! : 2 (0.5초 딜레이)
Hello, Async! : 3 (0.5초 딜레이)
Hello, Async! : 4 (0.5초 딜레이)
Hello, Async! : 5 (0.5초 딜레이)
Hello, Async! : 6 (0.5초 딜레이)
Hello, Async! : 7 (0.5초 딜레이)
Hello, Async! : 8 (0.5초 딜레이)
Hello, Async! : 9 (0.5초 딜레이)
Task done
```

### AsyncTest2
async 함수는 void 또는 Task 타입을 반환할 수 있다.<br/>
앞선 상황에서 "Hello, Async! : 0" 이 출력된 후 바로 "Hello, Main!" 메세지가 바로 출력되는 상황을 볼 수 있었다.

이를 해결하기 위해 void 였던 HelloAsync 함수의 반환 타입을 Task 로 바꿔주자.<br/>
그 수 Start 함수를 async으로 변경하여 HelloAsync 앞에 await 키워드를 붙여주면 Task.Delay(500)을 await 했던 것 처럼<br/>
HelloAsync 함수가 모두 끝나기 전까진 Start 함수가 잠시 블러킹 된다.

실행 결과

```
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
Hello, Async! : 4
Hello, Async! : 5
Hello, Async! : 6
Hello, Async! : 7
Hello, Async! : 8
Hello, Async! : 9
Task done
Hello, Main!
```

### AsyncTest3
함수는 자고로 반환값이 있어야 한다.<br/>
하지만 반환값이 Task로 고정되어버리는 async 함수의 경우 어떻게 값을 반환할까?

Task<T>를 사용하면 된다.<br/>
함수의 반환형을 Task<T>로 두게 되면 해당 함수는 T 형태를 반환할 수 있는 함수가 된다.

실행 결과

```
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
Hello, Async! : 4
Hello, Async! : 5
Hello, Async! : 6
Hello, Async! : 7
Hello, Async! : 8
Hello, Async! : 9
Task done
printed count : 10
```

### AsyncTest4
이런식으로도 활용할 수 있다.

비동기 함수를 활용한 무한루프 예제

실행결과

```
Hello, Async! : 0
...
Hello, Async! : 9
Task done
Hello, Async! : 0
...
Hello, Async! : 9
Task done
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
...
```

<br/>

## 7. 문제 발생시키기
다음과 같이 작업을 분할하여 1 ~ 1억까지 모두 더하는 코드를 작성해보자.

실행 결과

```
1655881334099458
273
```

첫쨋줄은 덧셈의 결과, 둘쨋줄은 걸린 밀리초다.<br/>
분명 우린 5000000050000000라는 결과를 기대했지만 웬 알 수 없는 수가 눈 앞에 놓였다.<br/>
이러한 상황을 이해하기 위해 덧셈의 연산 과정을 알아야 한다.

우리가 '+=' 수식을 사용하던 덧셈 연산은 세가지 과정으로 쪼개진다.

```
int temp = origin;
temp += num;
origin = temp;
```

이와 같이 기존 값을 복사한 후 더하고, 마지막에 기존 값에 덮어씌우는 방식이다.<br/>
하지만 덮어씌우기 전에 다른 스레드에서 덧셈 연산을 해버렸다면 어떻게 될까?

```
Thread1
(1) temp = 10 + 15
(3) origin = temp

Thread2
(2) temp = 10 + 10
(4) origin = temp
```
Thread1 에서 기존 10의 값에 15를 더하는 연산,<br/>
Thread2 에서 Thread1의 연산이 끝나기 전에 기존 값에 10을 더하는 상황이다.

예기치 않게 괄호() 안에 순서와 같이 실행되었다고 하자.<br/>
(1) Thread1 의 temp에는 기존 값 10 + 15 = 25 의 값이 들어있을 것이다.<br/>
(2) Thread2 의 temp에는 기존 값 10 + 10 = 20 의 값이 들어있을 것이다.<br/>
(3) Thread1 에서 기존 값에 연산 후 값 temp 를 덮어씌워 25 라는 값이 적용된다.<br/> 
(3) Thread2 에서 기존 값에 연산 후 값 temp 를 덮어씌워 20 라는 값이 적용된다.

우린 10 + 15 + 10 이라는 연산을 통해 35라는 값을 기대했지만<br/>
결과는 20으로 나오게 된다.<br/>
이처럼 여러개의 스레드에서 하나의 자원에 접근하면 예기치 못한 문제가 발생하게 된다.<br/>
이를 해결하기 위해 우리는 한번에 하나의 스레드만 접근할 수 있도록 해야한다.

<br/>

## 8. Lock
하나의 스레드만이 한 원소에 접근할 수 있도록 하는 행위를 locking 이라 한다.<br/>

1. MemoryBarrier
   - 실행 기점을 중심으로 공용 메모리를 동기화 함
   - 코드 재배치 등의 예외를 예방하는 데에 사용
2. Interlocked
   - 안전하게 기본 자료형 변수의 값을 수정함
3. Mutex
   - 프로세스간의 locking에 사용되는 lock 
   - 다만 Monitor와 lock()에 비해 대략 50배 정도 느림
4. Monitor (Semaphore)
   - 코드 블럭을 감싸 locking하는 방법
   - 탈출구를 만들어두지 않으면 데드락에 빠질 위험이 있음
5. lock()
   - 가장 많이 사용되는 locking 방식
   - Monitor보다 가독성이 높은 특징이 있음

locking을 하는 데에는 매우 많은 방법이 있지만 우리가 사용하는 C#에선 'lock()'만 기억하도록 하자

똥이 마려운 석현이가 화장실에 들렸다고 가정해보자.<br/>
자신감이 부족한 석현이는 프라이버시를 위해 화장실에 자물쇠를 건 후 볼일을 보았다.<br/>
석현이가 들어간지 얼마 되지 않아 똥이 마려운 부성이가 나타났다.<br/>
하지만 석현이가 "자리요"를 시전해버리는 바람에, 자물쇠가 걸려있어 부성이는 기다릴 수 밖엔 없었다.<br/>
그렇게 석현이가 볼일을 다 본 후 부성이는 급히 볼일을 보러 화장실에 들어가 자물쇠를 걸고 볼일을 보았다.

이러한 상황에서 자물쇠로 잠구는 행위가 locking이다.<br/>
C# 에 lock() 키워드를 사용하여 자물쇠를 잠구고 열 수 있다.<br/>
자물쇠를 잠구는 과정에서 '자물쇠'가 필요한데,<br/>
lock()의 매개변수로 object 형태의 객체를 넣어 자물쇠의 역할을 하도록 할 수 있다.<br/>
즉 매개변수로 사용되는 object 객체가 다른 어딘가에서 잠겨있다면 다른 스레드는 해당 자물쇠가 열릴 때까지 대기하는 방식이다.

하지만 locking을 하면 시작이 기하급수적으로 늘어나는 것을 볼 수 있다.<br/>
앞서 말했듯이 누군가 자물쇠를 잠궈뒀다면 풀릴 때까지 기다려야 함으로 이러한 과정에서 오버헤드가 발생하는 것이다.<br/>
따라서 locking은 꼭 필요한 곳에 신중하게 사용해야 한다.

<br/>