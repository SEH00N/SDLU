# <center>**멀티스레딩 기초**</center>

## 목차
1. 스레드 사용 방법
2. 환경 설정
3. Thread
   1. ThreadTest1
   2. ThreadTest2
   3. ThreadTest3
4. ThreadPool
5. Task
6. Async
7. 오류 발생시키기


<br/>

## 1. 스레드 사용 방법
우리가 사용하는 C#에선 총 네가지 방법으로 스레딩을 할 수 있다.

1. Thread
   - 이름 그대로 하나의 스레드를 생성하는 방식
2. ThreadPool
   - 사전에 스레드를 생성해두어 풀링하는 형식
3. Task
   - ThreadPool의 업그레이드 버전
4. Async/Awate
   - 내부적으로는 Task로 작동하는 비동기 프로그래밍 방식
   - 유니티의 코루틴과 비슷함

<br/>

## 2. 환경 설정
C# 콘솔 앱 선택<br/>
프로젝트 이름과 솔루션 이름을 Threading으로 설정<br/>
.NET 6.0 버전, 최상위 문 사용 안 함으로 프로젝트 생성

<br/>

## 3. Thread

### ThreadTest1
스레드를 두개 생성한 후 각각 생성자 매개변수로 Thread1, Thread2 메소드를 넘겨준다.<br/>
이름을 바꾼 후 각각 실행시켜준다.

```
Thread1, 1번 스레드
Thread2, 2번 스레드
```

또는

```
Thread2, 2번 스레드
Thread1, 1번 스레드
```

와 같이 출력되는 것을 볼 수 있다.<br/>
이로써 CPU가 스케줄링할 때 무엇을 먼저 하는 실행하는지에 따라 스레드의 실행 순서가 바뀐다는 것을 알 수 있다.

### ThreadTest2
아까와 같은 코드지만 이번엔 "This is main"이라는 출력을 하나 더 추가했다.

```
This is main
Hello, Thread1!
Hello, Thread2!
```

또는

```
This is main
Hello, Thread2!
Hello, Thread1!
```

와 같이 출력되는 것을 볼 수 있을 것이다.

<br/>

이번엔 thread1과 thread2의 Join() 함수를 호출한 후 실행해보자.

```
Hello, Thread1!
Hello, Thread2!
This is main
```

또는

```
Hello, Thread2!
Hello, Thread1!
This is main
```

와 같이 출력된다.

Join함수는 해당 스레드의 작업이 끝날 때까지 해당 스레드를 호출한 스레드를 멈추게 한다.<br/>
따라서 Join을 걸면 "This is main" 메세지가 항상 모든 스레드가 끝난 시점인 마지막에 뜨지만<br/>
Join을 하지 않으면 처음에 뜰지 중간에 뜰지 마지막에 뜰지 모른다.<br/>
하지만 대부분은 스레드 실행 순서 탓에 This is main이 처음에 뜰 것이다.

### ThreadTest3
첫 코드와 같은 코드지만 이번엔 "This is main"이라는 출력과 Thread1, Thread2의 작업을 for문으로 100번씩 실행하게 하였다.

```
This is main
Hello, Thread1! : 0
Hello, Thread1! : 1
Hello, Thread1! : 2
Hello, Thread1! : 3
...
Hello, Thread2! : 99
```

또는

```
This is main
Hello, Thread2! : 0
Hello, Thread2! : 1
Hello, Thread2! : 2
Hello, Thread2! : 3
...
Hello, Thread1! : 99
```

와 같이 출력된다.

이번엔 스레드들을 시작시키기 전에 각각 스레드의 IsBackground 속성을 true로 만들고 실행해보자.

```
This is main
Hello, Thread1! : 0
Hello, Thread1! : 1
Hello, Thread1! : 2
Hello, Thread1! : 3
...
Hello, Thread1! : 12
```

이런 식으로 예상했던 결과와 달리 애매하게 중간에서 종료되는 경우가 발생한다.

스레드는 BackgroundThread과 Foreground 스레드로 나뉜다.<br/>
BackgroundThread는 모든 Foreground 스레드가 종료되었을 때 같이 종료되는 스레드<br/>
메인스레드같은 하나의 Foreground 스레드라도 존재한다면 프로세스는 종료되지 않음

즉 생성자를 통해 생성한 스레드는 기본적으로 ForegroundThread로 분류되기 때문에 1번 테스트와 같은 결과가 나올 수 있었던 것이다.

<br/>

## 4. ThreadPool
스레드풀은 ThreadPool.QueueUserWorkItem() 함수를 통해 작업을 실행시킬 수 있다.

첫번째 매개변수로는 Action<object?> 형태의 콜백을 받고 두번째 매개변수로는 콜백의 매개변수로 넘길 object? 타입을 받는다.

실행 결과
```
This is main
Work1 : 10
Work2 : This is String
```

또는

```
This is main
Work2 : This is String
Work1 : 10
```

<br/>

## 5. Task
스태틱 함수 Task.Run() 또는 Task 객체를 생성해서 작업을 실행시킬 수 있다.<br/>
또한 Task.WaitAll()을 통해 Thread.Join() 함수를 대체 할 수 있다.

<br/>

## 6. Async
함수에 async 키워드를 붙여 비동기 함수를 생성할 수 있다.<br/>
비동기 함수는 내부적으로 Task를 활용해 작동된다.

### AsyncTest1
async 함수 내에서는 await이라는 키워드를 쓸 수 있다.<br/>
await은 작업을 기다리는 키워드로 await 오른쪽에 오는 Task 객체의 작업을 실행시킨 후 작업이 모두 끝날 때까지 기다린다.

Task.Delay(int millisecondsDelay) 함수는 매개변수로 들어온 밀리초 만큼의 딜레이를 가지는 작업을 반환한다.<br/>
즉 해당 작업을 await시킬 시에 매개변수로 넘긴 밀리초 만큼 기다리게 된다.

딜레이는 HelloAsync 함수가 실행중인 스레드에 적용되게에 "Hello, Async! : 0" 이 출력된 후 바로 "Hello, Main!" 메세지가 바로 출력되는 것을 볼 수 있다.<br/>
그 후로는 0.5초의 딜레이를 가지며 "Hello, Async! : n" 메세지가 출력된다.

실행 결과

```
Hello, Async! : 0 (0.5초 딜레이)
Hello, Main!
Hello, Async! : 1 (0.5초 딜레이)
Hello, Async! : 2 (0.5초 딜레이)
Hello, Async! : 3 (0.5초 딜레이)
Hello, Async! : 4 (0.5초 딜레이)
Hello, Async! : 5 (0.5초 딜레이)
Hello, Async! : 6 (0.5초 딜레이)
Hello, Async! : 7 (0.5초 딜레이)
Hello, Async! : 8 (0.5초 딜레이)
Hello, Async! : 9 (0.5초 딜레이)
Task done
```

### AsyncTest2
async 함수는 void 또는 Task 타입을 반환할 수 있다.<br/>
앞선 상황에서 "Hello, Async! : 0" 이 출력된 후 바로 "Hello, Main!" 메세지가 바로 출력되는 상황을 볼 수 있었다.

이를 해결하기 위해 void 였던 HelloAsync 함수의 반환 타입을 Task 로 바꿔주자.<br/>
그 수 Start 함수를 async으로 변경하여 HelloAsync 앞에 await 키워드를 붙여주면 Task.Delay(500)을 await 했던 것 처럼<br/>
HelloAsync 함수가 모두 끝나기 전까진 Start 함수가 잠시 블러킹 된다.

실행 결과

```
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
Hello, Async! : 4
Hello, Async! : 5
Hello, Async! : 6
Hello, Async! : 7
Hello, Async! : 8
Hello, Async! : 9
Task done
Hello, Main!
```

### AsyncTest3
함수는 자고로 반환값이 있어야 한다.<br/>
하지만 반환값이 Task로 고정되어버리는 async 함수의 경우 어떻게 값을 반환할까?

Task<T>를 사용하면 된다.<br/>
함수의 반환형을 Task<T>로 두게 되면 해당 함수는 T 형태를 반환할 수 있는 함수가 된다.

실행 결과

```
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
Hello, Async! : 4
Hello, Async! : 5
Hello, Async! : 6
Hello, Async! : 7
Hello, Async! : 8
Hello, Async! : 9
Task done
printed count : 10
```

### AsyncTest4
이런식으로도 활용할 수 있다.

비동기 함수를 활용한 무한루프 예제

실행결과

```
Hello, Async! : 0
...
Hello, Async! : 9
Task done
Hello, Async! : 0
...
Hello, Async! : 9
Task done
Hello, Async! : 0
Hello, Async! : 1
Hello, Async! : 2
Hello, Async! : 3
...
```

<br/>

## 7. 오류 발생시키기


<br/>