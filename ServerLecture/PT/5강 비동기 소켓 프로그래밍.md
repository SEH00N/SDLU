# <center>**비동기 소켓 프로그래밍**</center>

## 목차
1. 문제 해결 방법
2. 리스너와 커넥터
3. 프로젝트 생성
4. 서버
5. 클라이언트
6. 디버깅

<br/>

## 1. 문제 해결 방법
지난 시간엔 에코서버를 제작해보고 문제점을 찾았었다.<br/>
제작했던 에코 서버의 가장 큰 문제점은 스레드가 블러킹 되는 현상이었다.<br/>
스레드가 멈추지 않게 하기 위한 방법엔 바로 전 시간에 배운 비동기 프로그래밍이 있다.

우린 저번 에코서버를 제작할 때 Socket 클래스의 Accept, Send, Receive 함수를 사용했다.<br/>
이 함수를 비동기로 사용하려면 어떻게 해야할까?<br/>
개쩌는 마이크로소프는 우리같은 사람들을 위해 비동기 함수를 미리 제작해두었다.<br/>

Accept, Send, Receive 대신에 각각 AcceptAsync, SendAsync, ReceiveAsync 함수를 사용할 수 있다.<br/>
하지만 비동기 함수는 동기적 함수 Send와 Receive의 매개변수로 사용되었던 byte[] 대신,<br/>
SocketAsyncEventArgs를 매개변수로 받는 걸 알 수 있다.<br/>
SocketAsyncEventArgs가 도대체 뭘까?

MSDN에서는 소켓 비동기 통신에서 데이터를 안전하게 처리하기 위한 클래스라고 설명한다.<br/>
그냥 단순히 데이터를 운반하는 데이터 셔틀이라고만 알고 있으면 될 것 같다.

<br/>

## 2. 리스너와 커넥터
하지만 제작에 들어가기 전에 알고 있어야 할 게 있다.<br/>
비동기 함수를 사용하게 되면 소켓은 한번에 여러개의 요청을 받을 수도 있다.<br/>
그러다 보면 자원 선점에 의한 교착상태나 소켓의 부하가 커져 크래시가 날 수 있다.<br/>
따라서 비동기 통신을 할 땐 소켓에 직접적으로 요청을 하는 등의 방식으로 사용하는 건 좋지 않은 방법이라 할 수 있다.

이를 위해 우리는 리스너와 커넥터라는 친구를 만들 것이다.<br/>
리스너와 커넥터는 각각 서버와 클라이언트의 대행자로 내부에 소켓을 지니고 있다.<br/>
우리의 송수신 요청을 소켓 대신 리스너와 커넥터에 요청할 수 있다.<br/>
그럼 리스너와 커넥터는 소켓의 상태를 확인하며 안전한 송수신을 처리는 방식으로 작동해야 한다.

이러한 구조의 서버와 클라이언트를 비동기로 제작해보려 한다.

<br/>

## 3. 프로젝트 생성
솔루션의 이름은 AsyncEchoServer, 프로젝트의 이름은 Server로 프로젝트를 생성해준다.<br/>
Server 코드부터 제작해보자.

<br/>

## 4. 서버
### Listener
서버의 대행자 역할을 할 리스너의 기본적인 형태는 다음과 같다.<br/>
직접 통신을 할 listenSocket이 필요하고, 클라이언트들과 통신할 소켓들의 리스트가 있다.<br/>
생성자에는 소켓을 바인딩 하기 위한 IP 종단점과 백로그 수를 받는다.

### Accept
클라이언트를 받는 함수들이다.<br/>
여러 클라이언트를 수용해야하기 때문에 클라이언트를 받는 함수는 루프를 돌아야한다.<br/>
단순히 루프를 돌면 메인 스레드가 블러킹 되기에 우린 비동기 함수를 사용할 것이다.

루프를 돌기 위한 비동기 함수 구조에는 시작, 요청, 처리 이렇게 세가지로 나뉜다.<br/>
시작은 StartAccept, 실질적인 요청은 Accept, 처리는 OnAcceptCompleted 가 담당한다.

StartAccept에서는 요청이 이루어졌을 때 OnAcceptCompleted가 실행되도록 한 후 Accept를 호출하여 실질적인 요청을 넣는다.<br/>
Accept에서는 Socket 클래스에 있는 AcceptAsync를 통해 실질적인 클라이언트를 받는 작업을 한다.<br/>
AcceptAsync를 통해 클라이언트가 받아졌으면 아까 설정해두었던 OnAcceptCompleted가 실행된다.<br/>
OnAcceptCompleted에서는 받은 클라이언트 소켓을 리스트에 추가하고, 메세지를 받기 위한 처리를 해준다.<br/>

이론적으론 다음과 같은 구조로 소켓 비동기 루프가 이루어진다.<br/>
이젠 소스코드의 관점에서 이해해보자.

Listener를 사용하는 우리는 클라이언트와의 접속을 시작하기 위해 StartAccept를 호출할 것이다.<br/>
StartAccept에서는 앞서 배웠던 SocketAsyncEventArgs를 생성한 후 args의 Completed에 OnAcceptCompleted를 구독한다.<br/>
SocketAsyncEventArgs는 말 그대로 데이터를 보다 편히 처리하기 위한 도우미 클래스다.<br/>
SocketAsyncEventArgs의 Completed는 이름에서 알 수 있듯이 모든 처리가 끝났을 때 실행되는 콜백인다.<br/>
즉 모든 처리가 끝났을 때 OnAcceptCompleted가 호출되도록 해준 것이다.<br/>
하지만 실질적인 요청을 하는 부분은 Accept 함수이기 때문에 Accept를 호출할 때 매개변수로 args를 넘겨주도록 하자.

Accept 함수의 시작부분에 args.AcceptSocket을 null로 초기화해주는 것을 볼 수 있다.<br/>
우린 Accept 함수를 사용하여 루프를 돌 것이다.<br/>
하지만 매번 SocketAsyncEventArgs를 생성하고 OnAcceptCompleted를 구독하고... 이러한 작업들을 반복하는 것은 좋지 않은 선택이다.<br/>
따라서 우린 한 번 만들어둔 args 변수를 재사용할 것이다.<br/>
args.AcceptSocket는 AcceptAsync를 통해 클라이언트를 받아드렸을 때 받은 클라이언트가 담겨있는 필드변수이다.<br/>
즉 새로 Accept가 호출되었다는 건 다른 클라이언트가 받아지고 새로 받아드릴 요청을 하는 것이라는 의미다.<br/>
때문에 기존에 받아진 소켓이 담겨있을 args.AcceptSocket을 null로 밀어주는 것이다.

그 후 리슨소켓의 AcceptAsync 함수를 호출하고 매개변수로 args를 넘겨준다.<br/>
비동기 함수에선 언제 처리가 완료되어 다음 작업을 마무리할 수 있을지 모른다.<br/>
따라서 처리 결과, 상태, 콜백, 버퍼 등등.. 비동기 통신에 필요한 다양한 정보가 담겨있는 args를 매개변수로 넘겨준다.<br/>
여기까진 알겠는데 반환값으로 받은 pending이라는 놈은 무엇일까?<br/>
AcceptAsync 함수는 이미 대기열에 클라이언트가 존재한다면 처리가 바로 진행될 수도 있다.<br/>
즉 비동기적으로 돌아가지 않고 즉시 처리가 된다는 소리다.<br/>
이와 같은 경우에는 매개변수로 넘겨준 args가 갖고 있는 모든 처리가 끝났을 때 실행되는 콜백인 Completed 가 호출되지 않는다.<br/>
즉 바로 처리된 경우에는 구독해놨던 OnAcceptCompleted 함수가 실행되지 않기에 직접 OnAcceptCompleted 함수를 호출시켜 받아들인 소켓을 처리한다.<br/>
이런 경우가 아닐 때에는 정상적으로 args.Completed가 호출되어 OnAcceptCompleted 함수가 실행될 것이다.

OnAcceptCompletd는 말 그대로 받아들인 소켓을 처리하는 함수다.<br/>
즉 정삭적으로 통신되었다는 걸 확인한 후 StartRecieve를 통해 메세지 수신처리를 해주고 클라이언트 리스트에 넣어버린다.<br/>
그 후 다음 클라이언트를 받기 위해 다시 Accept를 호출하여 루프가 꺼지지 않도록 해준다.

이때 리스트에 추가하는 부분에 lock라는 키워드는 전 시간에 배웠던 라킹을 위한 부분이다.<br/>
메세지 전송, 클라이언트 퇴장, 클라이언트 수락 등 여러 작업에서 클라이언트 리스트를 사용하게 될 것이다.<br/>
하지만 각 작업은 별개의 스레드에서 작동되기 때문에 자원의 안전보장을 위해 lock을 걸어주도록 하자.

이러한 방식으로 Accept가 이루어진다.<br/>
소켓 비동기 루프에선 대부분이 이러한 방식으로 이루어지기 때문에 꼭 이해하고 넘어가도록 하자.

### Receive
Receive는 앞서 했던 Accept와 매우 비슷한 구조를 갖고있다.<br/>
따라서 자세한 설명은 생략하고 StartReceive 함수 부분의<br/>
SocketAsyncEventArgs의 UserToken,<br/>
Receive 부분의 Socket의 SetBuffer,<br/>
OnReceiveCompleted 의 onMessageReceive<br/>
부분만 알아보자.

Accept는 리슨 소켓과 SocketAsyncEventArgs만으로 클라이언트를 받아드린다.<br/>
하지만 Receive부분은 각 클라이언트 소켓으로부터 수신해야하고<br/> 따라서 OnReceiveCompleted 부분에서 다음 Receive를 호출시킬 때 socket이 필요하게 된다.<br/>
하지만 OnReceiveCompleted부분에서 socket을 넘겨받을 수 있는 방법이 없기 때문에 SocketAsyncEventArgs의 UserToken으로 socket을 넘겨주는 것이다.

> MSDN UserToken 설명
  - 이 비동기 소켓 작업과 연결된 사용자 또는 애플리케이션 개체를 가져오거나 설정합니다. 

SetBuffer는 비동기적으로 Receive를 할 때 데이터를 담을 버퍼를 세팅하는 함수이다.<br/>
ArraySegment는 배열을 동적으로 사용할 때 좀 더 원활히 사용하기 위한 구조체이다.

데이터에 대한 처리는 서버의 대행자인 Listener에서 해주기엔 다소 객체지향 적이지 않음이 있다.<br/>
따라서 누가 보냈는지(소켓), 어떤 걸 보냈는지(메세지) 를 매개변수로 넘겨주는 Action인 onMessageReceived를 만들어<br/>
외부에서 메세지를 핸들링 할 수 있도록 만든 것이다.

여기서 또한 여러 스레드에서 onMessageReceived를 접근하는 경우가 생기기 때문에 라킹해주도록 하자.<br/>
이 때 onMessageReceived를 라킹하는 자물쇠 (object 객체)와 리스트를 라킹해주는 자물쇠 (object 객체)는 별개로 두도록 하자.

### Kick
Kick 함수는 단순히 클라이언트를 내보내는 함수이다.<br/>
여기서 역시 마찬가지로 리스트에 라킹을 해주어야 한다.

### Listener
여러 변수들을 추가한 Listener의 필드 변수들은 다음과 같이 형성된다.

### Broadcast
전송하는 함수.

### Listener
최종 필드 변수와 생성자.

### Main
리스너 클래스를 나와서 Main 함수로 가보자.<br/>
현재 ipv4 주소로 8081 포트의 종단점과 메세지를 핸들링 할 OnMessageReceived 콜백으로 리스터를 생성해주자.<br/>
그 후 클라이언트를 받아드리는 루프를 실행시킨다.

### OnReceivedMessage
메세지는 저번 에코 서버와 마찬가지로 출력 후 돌려보내주도록 하자.

<br/>

## 5. 클라이언트
### 프로젝트 생성
Client 라는 이름의 프로젝트를 현재 솔루션에 추가해주자.

### Connector
클라이언트의 대행자 Connector의 클래스를 만든다.<br/>
연결할 종단점을 받는 생성자와 서버와 통신할 소켓을 만들어주자.

### Connect & Disconnect
연결이 되지 않은 상태에선 클라이언트가 굳이 작동할 필요가 없기 때문에<br/>
Connect는 동기함수를 사용해서 만들어주자<br/>
연결이 됐다면 메세지를 받을 수 있는 비동기 루프를 실행시켜준다 (StartReceive)

Disconnect는 저번에 했던 방법과 같이 제작한다.

### Receive
서버 쪽에서 사용했던 Receive와 똑같은 구조다.

### Connector
따라서 메세지를 핸들링 하기 위한 onMessageReceivedEvent를 만들어준다.<br/>
하지만 항상 서버 소켓으로 부터 메세지가 수신되기 때문에 Action의 매개변수로는 string만 넣어준다.

### Send
서버 측에서 사용했던 Broadcast와 비슷하지만 이번엔 모든 클라이언트가 아닌 서버 소켓에게만 보내주도록 한다.

### Connector
Send에서 사용될 SocketAsyncEventArgs도 필드변수에 만들어주자.

### Main
Connector 클래스에서 나와 main으로 가보자.<br/>
연결할 서버의 종단점과 메세지를 핸들링 할 OnMessageReceived 를 콜백으로 넘겨주어 Connector를 생성한다.<br/>
그 후 연결을 시도하자.

연결이 성공적으로 되었다면 와일 루프를 돌아 메세지를 전송할 수 있도록 해주자.

### OnMessageReceived
단순 출력.

<br/>

## 6. 디버깅
하나의 서버와 여러개의 클라이언트를 구동시켜야 하기 때문에 시작 프로젝트는 Server로 설정해준다.<br/>
그 후 Client 프로젝트를 우클릭하여 빌드시킨 후 서버를 실행시킨다.

빌드 된 경로로 가 클라이언트를 두개 혹은 세개를 실행시켜주자

성공적으로 연결이 되었다면 서버에는 접속한 클라이언트 들의 IP와 접속 로그가 뜰 것이다.<br/>
또한 각각 클라이언트들은 서버와 연결되었다는 로그가 뜬다.

그 후 하나의 클라이언트에서 메세지를 보내면 다른 클라이언트와 서버에도 로그가 뜨는 것을 확인할 수 있다.

이걸로 비동기 입문을 마친다.

<br/>