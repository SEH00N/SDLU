# <center>**네트워크 프레임워크 제작**</center>

## 목차
1. 프레임워크 구조
   1. Session
   2. Buffer
   3. SharedBuffer
   4. Packet
   5. UniqueBuffer
   6. JobQueue
2. 네트워크 프레임워크 구현
3. 프레임워크 예제
   1. Packets
   2. Client
   3. Server

<br/>

## 1. 프레임워크 구조
기존의 리스너와 커넥터는 각각 서버와 클라이언트를 대신하는 역할이었다.<br/>
하지만 우리가 앞으로 만들 리스너와 커넥터는 단지 연결을 위한 수단으로만 사용할 것이다.

그렇기에 통신을 담당하는 '세션'이란 것을 만들 것이다.

<br/>

## 1 - 1. Session
세션은 간단히 말해 '연결 상태'다.

커넥터가 리스너에 접속하여 연결됐을 때 '세션'이라는 놈을 생성할 것이다.<br/>
커넥터의 세션은 리스너와 통신하기 위한 공간,<br/>
리스너의 세션은 커넥터와 통신하기 위한 공간이 된다.

리스너와 커넥터는 연결 기기, 세션은 통신공간 이라고 기억해두자.

<br/>

## 1 - 2. Buffer
기존 Receive 하는 과정에선 소켓에 버퍼를 세팅할 때마다 매번 byte의 배열을 생성했다.<br/> 
소켓에 세팅한 버퍼가 다 사용되지 못했을지라도 새로 만들어버린다.

그렇게 되면 그 전에 사용중이던 버퍼는 쓰레기가 되고,<br/>
가비지 콜렉터의 호출 회수는 자연스럽게 늘어난다.

그렇기 때문에 우린 한번 만든 버퍼, 즉 메모리를 재활용 할 것이다.

<br/>

## 1 - 3. SharedBuffer
SharedBuffer라 불리는 재활용 가능한 버퍼를 만들 것이다.

기존엔 버퍼 사용 후 새로 버퍼를 만들었다면 재활용 가능한 버퍼에선 그대로 놔둔다.<br/>
그리고 새로 값을 적을 때 사용된 공간 뒤에서부터 값을 적기 시작한다.

이렇게 되었을 때 다른 스레드는 사용된 공간, 즉 버퍼에 적힌 데이터를 읽어드려 처리할 수 있다.<br/>
이와 마찬가지로 또 다른 스레드는 다른 스레드가 데이터를 읽고있을 때에도 버퍼에 데이터를 적을 수 있다.

이때 우린 데이터를 읽어야 하는 위치 ReadCursor와 데이터를 적을 위치 WriteCursor를 둘 것이다.

```
처리된 공간 : 시작 ~ ReadCursor
사용된 공간 : ReadCursor ~ WriteCursor
사용 가능한 공간 : WriteCursor ~ 끝
```

이와같이 버퍼의 공간을 나눌 것이다.

버퍼를 사용하다가 버퍼의 공간이 부족해지게 되면,<br/>
'사용된 공간', 즉 남아있는 데이터를 앞으로 당겨서 '처리된 공간', 즉 필요 없는 공간을 덮어씌워버린다.<br/>
이렇게 했을 때 기존에 '처리된 공간'에 데이터는 사라지고, '사용된 공간'의 데이터가 앞으로 오게 된다.<br/>
자연스레 '사용된 공간' 뒤에는 임의의 값이 있을지라도 '사용 가능한 공간'으로 식별할 수 있다.

이러한 과정을 '버퍼를 정화한다'라는 의미로 Purify라 부를 것이다.<br/>
공간을 정화하고 난 후 공간들을 다시 식별할 수 있도록 ReadCursor와 WriteCursor를 업데이트 시켜주면 된다.

이처럼 메모리를 재활용하고 읽기와 쓰기를 따로따로 처리하는 버퍼를 'SharedBuffer'라 부를 것이다.

하지만 Receive가 아닌 Send 상황에선 SharedBuffer를 사용하지 못한다.<br/>
이에 대해 자세히 알기 위해선 우리가 통신할 때 사용할 패킷의 구조를 알아야한다.

<br/>

## 1 - 4. Packet
직렬화된 데이터를 패킷이라 부른다.

직렬화는 특정 형식의 데이터를 어느 곳에서든 쓸 수 형태로 나열한 것을 말한다.<br/>
그렇기에 대부분의 직렬화에선 데이터를 바이트의 배열로 나열한다.<br/>
즉 앞서 말한 패킷은 데이터를 바이트의 배열로 변환했을 때의 값이라 생각하면 된다.

우린 패킷을 다음과 같이 직렬화 하여 전송할 것이다.

```
이동패킷
int playerID
int x
int y
int z

[패킷 사이즈][playerID][x][y][z]
```
이렇게 패킷을 읽어드릴 수 있도록 패킷의 사이즈를 가장 앞에다가 'Header'라는 이름으로 작성한 후<br/>
그 뒤에 데이터를 나열할 것이다.

```
채팅패킷
string name
string message

[패킷 사이즈][문자열 길이][name][문자열 길이][message]
```
하지만 이와 같이 가변길의 패킷인 경우 패킷의 사이즈는 매번 달라지게 된다.<br/>
이러한 상황에서 SharedBuffer를 사용하면 어떻게 될까?

채팅패킷을 직렬화하기 위해 SharedBuffer에서 데이터가 작성될 공간을 요청한다.<br/>
SharedBuffer는 WriteCursor ~ 끝까지의 공간을 제공한다.<br/>
채팅패킷이 제공받은 공간에 데이터를 작성하던 중에 또 다른 패킷이 공간을 요청하는 경우에 문제가 생긴다.

SharedBuffer는 똑같이 WriteCursor ~ 끝까지의 공간을 제공할 것이다.<br/>
하지만 앞선 채팅패킷이 WriteCursor를 업데이트 하지 않았기 때문에 채팅패킷에게 제공된 공간이 똑같이 제공된다.<br/>
제공받은 공간부터 데이터를 작성하게 되면 채팅패킷이 작성하던 데이터는 덮어씌워져 버퍼가 꼬이게 된다.

그렇다면 채팅패킷이 공간을 받자마자 WriteCursor를 업데이트 해주면 되지 않을까? 라는 질문이 들었다면 채팅패킷이 가변길이임을 생각해보자.<br/>
모든 문자열 혹은 배열을 직렬화 한 후에야 현재 패킷의 길이를 알 수 있다.<br/>
그렇기에 가변길이 패킷을 직렬화하는 중에 문제를 해결하지 못하는 것이다.

그럼 여러 스레드가 동신 접근하지 못하도록 lock을 걸면 되지 않을까?<br/>
이것 또한 하나의 해결방법이지만 lock은 굉장히 많은 퍼포먼스 저하를 불러온다는 것을 기억해야 한다.<br/>
따라서 최소한의 lock으로만 자원의 안전성을 지키는 것이 좋다.

그렇 어떻게 할까?<br/>
이에 대한 해결방안으로 UniqueBuffer를 만들 것이다.

<br/>

## 1 - 5. UniqueBuffer
우린 데이터를 안전하게 지키기 위해 Lock을 걸어준다.

데이터를 안전하게 지킨다는 의미는 여러 스레드가 하나의 자원을 사용하고, 읽어야 한다는 소리다.

하지만 Send와 같은 상황에선 여러개의 스레드가 하나의 데이터를 읽을 필요가 없다.<br/>
단지 데이터를 작성할 공간을 제공하기 위한 목적이다.

단지 공간을 제공하고 자원의 동시 접근을 제한하기 위해서라면<br/>
스레드별로 하나씩 공간을 갖고있도록 하는 해결방안을 낼 수 있다.

이러한 기능을 제공하는 것이 C# 의 TreadLocal이다.<br/>
ThreadLocal은 서로 힙 영역을 공유하는 스레드의 특성을 제한하기 위한 클래스다.<br/>
ThreadLocal을 사용하게 되면 스택 영역처럼 스레드별로 하나씩 변수를 가질 수 있게 된다.

이 TreadLocal을 사용해서 각 스레드가 하나씩 SharedBuffer를 가지도록 하는 유틸리티를 UniqueBuffer라고 부를 것이다.

<br/>

## 1 - 7. JobQueue
개발을 하다보면 자원도 많아지고 스레드도 많아진다.<br/>
하지만 매 자원마다 lock을 걸기엔 성능이 저하될 뿐더러

```
lock
{
    lock
    {
        lock
        {
            ...
        }
    }
}
```
이처럼 락이 재귀되는 상황또한 벌어지며 교착상태에 빠질 수도 있다.<br/>
그렇다고 모든 상황을 고려하며 lock을 걸기엔 머리가 터져버리고 말 것이다.

그렇기 때문에 자원의 안전성을 위협하는 '작업' 자체를 lock으로 매핑할 것이다.<br/>
그게 바로 JobQueue다.

Task.Run 처럼 JobQueue에 작업을 요청하면 작업을 Queue에 하나씩 쌓는다.<br/>
그리고 작업을 실행할 수 있을 때마다 Queue를 비우며 요청받은 작업들을 하나씩 실행한다.

이러한 구조에서 꼭 나오는 질문이 있다.

**그럼 작업들이 직렬적으로 실행되는 거 아니에요??**<br/>
맞다.

**그럼 멀티스레딩 왜 써요??**<br/>
그렇기에 자원의 안전성을 위협하지 않도록 구조를 짜고 불가피한 상황 속에서만 JobQueue를 사용하는 것이 좋다.

JobQueue를 사용하면 병렬성은 떨어지지만 안전성은 보장할 수 있다.<br/>
괜히 허접하게 락킹하는 것 보단 JobQueue를 사용하는게 더 나을 것이다.

## 2. 네트워크 프레임워크 구현
방금 배운 구조로 프레임워크를 제작할 것이다.

프레임워크는 라이브러리로써 사용될 것이기 때문에 '클래스 라이브러리'로 프로젝트를 생성해준다.<br/>
유니티에서 .NET Standard 2.x 이상의 라이브러리 파일을 사용하면 호환성의 문제가 생길 수 있기에<br/>
유니티에서 사용할 수 있도록 .NET Standard 2.1로 프로젝트를 생성해주자.

앞서 공부한 이론을 바탕으로 제작되기 때문에 코드 한줄한줄에 대한 설명은 생략한다.<br/>
자세한 설명은 첨부된 파일의 주석을 참고하길 바란다.<br/>
(질문은 디스코드 seh00n)

[네트워크 프레임워크 바로가기](../NetworkFramework/H00N.Network/)

## 3. 프레임워크 예제
제작한 프레임워크를 사용하여 채팅서버를 제작해보자.

## 3 - 1. Packets
클라이언트와 서버가 송수신할 데이터가 되는 패킷들을 정의해야한다.

이 또한 라이브러리로 사용되기에 클래스 라이브러리로 프로젝트를 추가해준다.<br/>
역시 마찬가지로 유니티에서 사용할 수 있도록 .NET Standard 2.1로 프로젝트를 생성해주자.<br/>
(Client 프로젝트나 Server 프로젝트는 닷넷 6.0으로 열어도 됨. 유니티에서 '라이브러리'로 사용할 것만 .NET Standard 2.1으로 열기)<br/>
그 다음 미리 정의해둔 프레임워크를 사용하기 위해 빌드해둔 프레임워크의 dll 파일을 참조시킨다.<br/>
(경로 : 솔루션폴더/프로젝트폴더/bin/Debug 혹은 Release/netstandard2.1/\[자신의프레임워크이름\].dll)

단지 프레임워크를 익히기 위한 간단한 예제이기에 코드 한줄한줄에 대한 설명은 생략한다.<br/>
자세한 설명은 첨부된 파일의 주석을 참고하길 바란다.

[채팅서버 패킷 바로가기](../NetworkFramework/Packets/Packtes/)

## 3 - 2. Client
텍스트를 보내고 받을 클라이언트를 제작해야한다.

콘솔 앱으로 프로젝트를 추가해준다.<br/>
그 다음 미리 정의해둔 프레임워크와 패킷을 사용하기 위해 빌드해둔 두 dll 파일을 참조시킨다.<br/>
(경로 : 솔루션폴더/프로젝트폴더/bin/Debug 혹은 Release/netstandard2.1/\[자신의프레임워크이름\].dll)<br/>
(경로 : 솔루션폴더/프로젝트폴더/bin/Debug 혹은 Release/netstandard2.1/packets.dll)

단지 프레임워크를 익히기 위한 간단한 예제이기에 코드 한줄한줄에 대한 설명은 생략한다.<br/>
자세한 설명은 첨부된 파일의 주석을 참고하길 바란다.

[채팅서버 클라이언트 바로가기](../NetworkFramework/TestClient/)

## 3 - 3. Server
채팅하는 클라이언트들을 관리할 서버를 제작해야한다.

콘솔 앱으로 프로젝트를 추가해준다.<br/>
그 다음 미리 정의해둔 프레임워크와 패킷을 사용하기 위해 빌드해둔 두 dll 파일을 참조시킨다.<br/>
(경로 : 솔루션폴더/프로젝트폴더/bin/Debug 혹은 Release/netstandard2.1/\[자신의프레임워크이름\].dll)<br/>
(경로 : 솔루션폴더/프로젝트폴더/bin/Debug 혹은 Release/netstandard2.1/packets.dll)

단지 프레임워크를 익히기 위한 간단한 예제이기에 코드 한줄한줄에 대한 설명은 생략한다.<br/>
자세한 설명은 첨부된 파일의 주석을 참고하길 바란다.

[채팅서버 서버 바로가기](../NetworkFramework/TestServer/)