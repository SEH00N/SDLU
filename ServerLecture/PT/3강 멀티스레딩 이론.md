# <center>**멀티스레딩 이론**<center/>

## 목차
1. 스레드
2. 멀티스레딩
3. 컨텍스트 스위칭
4. 컨텍스트 스위칭 오버헤드
5. 멀티스레딩 주의점

<br/>

## 1. 스레드
따로 정리해둔 블로그 글 참조 <br/>
[바로가기](https://velog.io/@sehoon/thread)

<br/>

## 2. 멀티 스레드
보통 속도를 향상시켜야 하는 상황이나 프로세스가 블로킹 되는 현상을 막아야 하는 상황에서의 해결책으로 '멀티 스레딩'이 많이 나오기 마련이다.

그렇다면 멀티 스레딩은 무엇일까?

스레드를 관리하는 프로세스는 한 개 이상의 스레드를 가질 수 있다.<br/>
이 말은 즉 프로세스를 작동시키기 위한 작업을 두 개 이상으로 분할시킬 수 있다는 뜻이다.

기본적으로 프로그램을 실행시키면 '메인 스레드' 라 불리는 스레드가 생성된다.<br/>
메인 스레드에서 새로운 스레드를 만들고 작업을 나눠서 처리하는 등의 방식 또는 환경을 멀티스레딩이라 한다. 

<br/>

## 3. 컨텍스트 스위칭 ( Context Switching )
멀티 스레딩 환경을 구축하기 위해선 '컨텍스트 스위칭'이 무엇인지 알아야 한다.

스레드 동작 과정을 다시 한번 짚어보자
스레드를 넘겨받은 CPU는 대기중인 코어를 찾아 스레드를 할당한다.
이 과정에서 기존에 코어가 실행중이던 스레드가 새로 할당받은 스레드로 변경되는 것을 말한다.

컨텍스트 스위칭에는 '프로세스 컨텍스트 스위칭'과 '스레드 컨텍스트 스위칭'이 있다.

앞선 설명에 의하면 기존의 스레드에서 새로 할당받은 스레드로 바뀌는 것이 컨텍스트 스위칭이라 했기에 '프로세스 컨텍스트 스위칭'은 다소 의아해 보일 수 있다.

'스레드 컨텍스트 스위칭'은 컨텍스트 스위칭이 일어날 때 서로 같은 프로세스의 스레드끼리 일어나는 컨텍스트 스위칭을 말한다.

반대로 '프로세스 컨텍스트 스위칭'은 서로 다른 프로세스의 스레드끼리 일어나는 컨텍스트 스위칭을 말한다.

즉 프로세스 컨텍스트 스위칭도 스레드 간의 컨텐스트 스위칭으로 작동한다.

## 컨텍스트 스위칭 오버헤드 ( Context Switching Overhead )
프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이점 중 꼭 알아야 할 중요한 차이는 '컨텍스트 스위칭 오버헤드'( Context Switching Overhead )이다.
그냥 컨텍스트 스위칭 비용이란 뜻이다.

컨텍스트 스위칭 비용을 알기 위해서 PCB, TCB를 알아야 한다.

PCB ( Process Control Block ), 프로세스 제어 블록은 프로세스의 정보를 담고있는 단위이다.
즉 OS가 스케줄링 할 때 프로세스를 식별하는 단위가 PCB인 것이다.

PCB에는 다음과 같은 정보가 있다.

1. Process ID ( 프로세스 아이디 )
    - 프로세스 고유 번호 ( 식별 아이디 )
2. Process State ( 프로세스 상태 )
    - 준비, 대기, 실행 등 상태
3. Program Counter ( 프로그램 계수기 )
    - 다음 실행될 명령어의 주소
4. Register Information ( 레지스터 정보 )
    - 레지스터 관련 정보
5. Scheduling Information ( 스케줄링 정보 )
    - 스케줄링에 사용되는 우선순의 등의 정보
6. Memory Related Information ( 메모리 정보 )
    - 할당된 자원에 대한 정보
7. Account Information ( 계정 정보 )
    - CPU 사용 시간, 실제 사용된 시간
8. Status Information Related to I/O ( 입출력 상태 정보 )
    - 입력과 출력에 대한 상태 정보

TCB ( Thread Control Block ), 스레드 제어 블록은 스레드의 정보를 담고있는 단위이다.

TCB에는 다음과 같은 정보가 있다.

1. Thread ID
    - 스레드 고유 번호 ( 식별 아이디 )
2. Stack Pointer
    - 스레드는 같은 프로세스의 Code, Data, Heap 메모리 영역을 공유하지만 Stack 메모리 영역은 고유한 영역을 보유하고 있다  
    - 고유 스택 메모리 주소
3. Program Counter
    - 현재 실행될 명령어 주소
4. Thread State
    - 스레드의 상태
5. Register Information
    - 레지스터 관련 정보
6. PCB Pointer
    - 현재 스레드가 작동중인 프로세스 정보 주소

즉 프로세스는 PCB를 통해 관리하고 스레드는 TCB를 통해 관리한다.
따라서 스레드 컨텍스트 스위칭이 일어날 때는 TCB가, 프로세스 컨텍스트 스위칭이 일어날 때는 PCB가 사용된다.

기존에 하던 작업을 끝내고 새로운 작업을 하려면 컨텍스트 저장과 복원이 이루어진다.
컨텍스트 저장은 현재 작업중인 내용을 TCB 또는 PCB에 저장하는 것을 말하고 복원은 새로 할당받은 TCB 또는 PCB의 정보를 바탕으로 CPU 코어가 작업 환경을 재구성하는 것을 말한다.

이러한 과정을 진행하는 데에 드는 비용을 Context Switching Overhead 즉 컨텍스트 스위칭 비용이라 한다.

당연히 TCB는 PCB보다 적은 양의 정보를 담고있다.
그렇기에 PCB를 사용하는 컨텍스트 스위칭, 즉 프로세스 컨텍스트 스위칭에는 많은 비용이 들며 TCB를 사용하는 컨텍스트 스위칭, 스레드 컨텍스트 스위칭엔 보다 적은 오버헤드가 발생한다.

하지만 스레드 컨텍스트 스위칭 오버헤드도 무시해선 안 된다.

## 멀티스레딩 주의점
멀티스레딩을 하다보면 하나의 프로세스에서 여러개의 스레드를 사용하게 되고, 당연스레 컨텍스트 스위칭이 자주 일어나게 된다.<br/>
하지만 스레드 컨텍스트 스위칭이라 할지라도 무시 못할 비용이 들게 된다.<br/>
따라서 컨텍스트 스위칭을 고려한 프로그래밍을 해야한다.

만약 쿼드 코어 CPU를 사용하는 컴퓨터라고 해보자.<br/>

어느 멀티스레딩 광신도 개발자가 400개의 스레드를 사용하는 프로그램을 만들었다. 여러가지 변수가 존재하겠지만 모든 스레드를 한번에 실행시킬수 있다면 하나의 스레드가 1초가 걸리는 작업을 담당하여 총 400초가 걸리는 작업을 1초만에 끝낼 수 있는 것이다.

하지만 쿼드 코어를 사용하는 나의 컴퓨터는 한번에 4개의 스레드밖에 실행하지 못한다. 따라서 400개의 스레드를 한번에 4개씩 100번에 걸쳐서 실행해야 한다. 이에 따라 100초라는 실행 시간이 걸릴 것이다

하지만 각 코어가 100번씩 걸쳐서 실행한단 소리는 컨텍스트 스위칭이 각 100번 일어난다는 소리다. 즉 100번의 스위칭 오버헤드가 발생한다는 소리다. 그렇다면 100초라는 시간조차 기대하기 힘들 수 있다.

즉 아무리 멀티스레딩 환경을 구축한다 할지라도 컨텍스트 스위칭을 고려하지 않으면 싱글스레드 환경보다 못한 퍼포먼스를 낼 수 있다.<br/>
멀티스레딩 환경을 구축할 땐 꼭 알아두도록 하자.